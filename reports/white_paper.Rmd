---
title: "Demographic & Housing Market Analysis"
subtitle: "Jefferson County, AL Portfolio Assessment"
author: "Xiaosong Zhang"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  html_document:
    theme: flatly
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: hide
    self_contained: true
---

<style>
/* Only custom components not covered by theme */
.metrics-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 20px; margin: 30px 0; }
.metric { text-align: center; padding: 25px 15px; border-left: 4px solid #18bc9c; background: #f8f9fa; border-radius: 4px; }
.metric.growth { border-left-color: #18bc9c; }
.metric.stable { border-left-color: #f39c12; }
.metric.weakening { border-left-color: #e74c3c; }
.metric-value { font-size: 2.8rem; font-weight: 700; color: #2c3e50; }
.metric-label { font-size: 1rem; color: #7b8a8b; text-transform: uppercase; letter-spacing: 0.05em; margin-top: 8px; }
.metric-sublabel { font-size: 0.9rem; color: #95a5a6; margin-top: 8px; }
.insight { background-color: #ecf0f1; border-left: 4px solid #3498db; padding: 15px 20px; margin: 20px 0; border-radius: 4px; }
.key-finding { background: #18bc9c; color: white; padding: 20px; border-radius: 6px; margin: 25px 0; }
.key-finding strong { color: white; }
.col-container { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 30px 0; }
.col-container-thirds { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 30px 0; }
.technical-note { font-size: 0.85rem; color: #7b8a8b; font-style: italic; padding-left: 15px; border-left: 2px solid #ecf0f1; }
.methodology { background-color: #f8f9fa; padding: 25px; margin-top: 40px; border-radius: 6px; }
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center",
  fig.width = 10,
  fig.height = 5,
  dpi = 150
)

library(tidyverse)
library(sf)
library(leaflet)
library(scales)
library(tigris)
library(knitr)
library(gridExtra)

# Helper: year axis breaks (used throughout)
year_breaks <- function(x) seq(floor(min(x)), ceiling(max(x)), by = 2)

# Load Data
final_data <- read_rds("../data/processed/final_analytical_data.rds")
properties <- final_data$property_reference
property_crosswalk <- final_data$property_crosswalk
tract_counts <- final_data$tract_counts
zcta_counts <- final_data$zcta_counts
tract_history <- final_data$tract_history
zcta_history <- final_data$zcta_history
zcta_history_full <- final_data$zcta_history_full
tract_classifications <- final_data$tract_classifications
zcta_classifications <- final_data$zcta_classifications
zcta_classifications_full <- final_data$zcta_classifications_full
county_history_5yr <- final_data$county_history_5yr
county_history_1yr <- final_data$county_history_1yr
variable_dictionary <- final_data$variable_dictionary

options(tigris_use_cache = TRUE)

# Use county 1-year data if available for most recent trends, otherwise 5-year
county_panel <- if(nrow(county_history_1yr) > 0) county_history_1yr else county_history_5yr

# Analysis periods
years_range <- range(tract_history$year, na.rm = TRUE)
analysis_period <- paste(years_range, collapse = "–")

# County data period (uses 1-year ACS if available)
county_years_range <- range(county_panel$year, na.rm = TRUE)
county_period <- paste(county_years_range, collapse = "–")

# Portfolio summary
prop_with_classification <- properties %>%
  left_join(tract_classifications, by = c("tract_geoid" = "GEOID"))

total_properties <- nrow(properties)
properties_with_tract <- sum(!is.na(properties$tract_geoid))
growth_properties <- sum(prop_with_classification$classification == "Growth", na.rm = TRUE)
stable_properties <- sum(prop_with_classification$classification == "Stable", na.rm = TRUE)
weakening_properties <- sum(prop_with_classification$classification == "Weakening", na.rm = TRUE)

# Safe percentage calculation
pct_growth <- if(properties_with_tract > 0) growth_properties / properties_with_tract else 0
pct_stable <- if(properties_with_tract > 0) stable_properties / properties_with_tract else 0
pct_weakening <- if(properties_with_tract > 0) weakening_properties / properties_with_tract else 0
pct_favorable <- pct_growth + pct_stable

# Portfolio financials summary
total_acquisition <- sum(properties$acquisition_cost, na.rm = TRUE)
total_renovation <- sum(properties$renovation_cost, na.rm = TRUE)
total_investment <- sum(properties$total_cost, na.rm = TRUE)
total_fmv <- sum(properties$fair_market_value, na.rm = TRUE)
total_equity <- sum(properties$equity, na.rm = TRUE)
avg_equity_per_property <- total_equity / total_properties

# County-level summary stats
latest_county <- county_panel %>% filter(year == max(year))
earliest_county <- county_panel %>% filter(year == min(year))

pop_change_county <- (latest_county$total_popE - earliest_county$total_popE) / earliest_county$total_popE
income_change_county <- (latest_county$med_income_real - earliest_county$med_income_real) / earliest_county$med_income_real
vacancy_change_county <- latest_county$vacancy_rate - earliest_county$vacancy_rate

# Tract-level aggregates for portfolio tracts only
portfolio_tracts <- prop_with_classification$tract_geoid %>% na.omit() %>% unique()

tract_latest <- tract_history %>%
  filter(GEOID %in% portfolio_tracts, year == max(year))

tract_earliest <- tract_history %>%
  filter(GEOID %in% portfolio_tracts, year == min(year))

# Average metrics across portfolio tracts (weighted by tract population)
avg_tract_metrics_latest <- tract_latest %>%
  summarise(
    avg_income = weighted.mean(med_income_real, total_popE, na.rm = TRUE),
    avg_vacancy = weighted.mean(vacancy_rate, total_unitsE, na.rm = TRUE),
    avg_renter_pct = weighted.mean(pct_renter, total_unitsE, na.rm = TRUE),
    avg_bachelors_pct = weighted.mean(pct_bachelors, edu_totalE, na.rm = TRUE)
  )

# Financials by classification
financials_by_class <- prop_with_classification %>%
  group_by(classification) %>%
  summarise(
    n_properties = n(),
    total_equity = sum(equity, na.rm = TRUE),
    avg_equity = mean(equity, na.rm = TRUE),
    total_fmv = sum(fair_market_value, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(classification = coalesce(classification, "Unclassified"))
```

## Executive Summary

This report analyzes demographic and housing market trends in Jefferson County, Alabama, with specific focus on the `r total_properties` properties in the portfolio. Tract-level analysis uses ACS 5-year estimates (`r analysis_period`), while county-level trends use ACS 1-year estimates (`r county_period`, excluding 2020). All monetary values are inflation-adjusted to 2023 dollars using CPI-U.

<div class="key-finding">
**Key Finding:** Of the `r total_properties` properties analyzed, **`r growth_properties + stable_properties`** (`r percent(pct_favorable, 0.1)`) are located in census tracts classified as "Growth" or "Stable," characterized by improving or steady population, income, and occupancy trends. Only **`r weakening_properties`** properties (`r percent(pct_weakening, 0.1)`) sit in tracts showing signs of demographic stress.
</div>

### Portfolio Financial Summary

The portfolio represents **`r dollar(total_investment)`** in total investment across `r total_properties` properties, with current fair market value of **`r dollar(total_fmv)`** and aggregate equity of **`r dollar(total_equity)`**.

```{r financials_by_classification}
financials_by_class %>%
  filter(!is.na(classification)) %>%
  arrange(factor(classification, levels = c("Growth", "Stable", "Weakening"))) %>%
  transmute(
    Classification = classification,
    Properties = n_properties,
    `Total FMV` = dollar(total_fmv),
    `Total Equity` = dollar(total_equity),
    `Avg Equity/Property` = dollar(avg_equity)
  ) %>%
  kable(align = c("l", "c", "c", "c", "c"))
```

### Portfolio Geographic Distribution

<div class="metrics-grid">
<div class="metric">
<div class="metric-value">`r total_properties`</div>
<div class="metric-label">Total Properties</div>
</div>

<div class="metric">
<div class="metric-value">`r length(portfolio_tracts)`</div>
<div class="metric-label">Census Tracts</div>
</div>

<div class="metric">
<div class="metric-value">`r growth_properties`</div>
<div class="metric-label">Growth Tracts</div>
<div class="metric-sublabel">`r percent(growth_properties/properties_with_tract, 0.1)` of portfolio</div>
</div>

<div class="metric">
<div class="metric-value">`r stable_properties`</div>
<div class="metric-label">Stable Tracts</div>
<div class="metric-sublabel">`r percent(stable_properties/properties_with_tract, 0.1)` of portfolio</div>
</div>

<div class="metric">
<div class="metric-value">`r weakening_properties`</div>
<div class="metric-label">Weakening Tracts</div>
<div class="metric-sublabel">`r percent(weakening_properties/properties_with_tract, 0.1)` of portfolio</div>
</div>
</div>

<div class="technical-note">
**Classification Methodology:** Tracts are classified based on statistically significant changes (using ACS margins of error) in population, real median household income, and vacancy rates over the analysis period. See Technical Appendix for details.
</div>

---

## Jefferson County Market Overview

### Population Trends

```{r county_population, fig.height=4.5}
county_panel %>%
  ggplot(aes(x = year, y = total_popE)) +
  geom_line(linewidth = 1.2, color = "#2c3e50") +
  geom_point(size = 2.5, color = "#2c3e50") +
  scale_x_continuous(breaks = function(x) seq(floor(min(x)), ceiling(max(x)), by = 1)) +
  scale_y_continuous(labels = comma, expand = c(0.05, 0)) +
  labs(
    title = "Jefferson County Total Population",
    subtitle = paste0("Change: ", percent(pop_change_county, 0.1), " over period"),
    x = NULL,
    y = "Population"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(color = "#666", size = 12),
    panel.grid.minor = element_blank()
  )
```

### Economic Fundamentals

```{r county_income, fig.height=4, fig.width=10}
county_panel %>%
  ggplot(aes(x = year, y = med_income_real)) +
  geom_line(linewidth = 1.2, color = "#27ae60") +
  geom_point(size = 2.5, color = "#27ae60") +
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed", color = "#27ae60", alpha = 0.3) +
  scale_x_continuous(breaks = year_breaks) +
  scale_y_continuous(labels = dollar, expand = c(0.05, 0)) +
  labs(
    title = "Median Household Income",
    subtitle = paste0("Real (2023$) change: ", percent(income_change_county, 0.1)),
    x = NULL,
    y = "Income (2023$)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 15),
    plot.subtitle = element_text(color = "#666", size = 11),
    panel.grid.minor = element_blank()
  )
```

```{r county_employment, fig.height=4, fig.width=10}
county_panel %>%
  select(year, unemployment_rate, poverty_rate) %>%
  pivot_longer(-year, names_to = "metric", values_to = "rate") %>%
  mutate(metric = case_when(
    metric == "unemployment_rate" ~ "Unemployment Rate",
    metric == "poverty_rate" ~ "Poverty Rate"
  )) %>%
  ggplot(aes(x = year, y = rate, color = metric)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2.5) +
  scale_x_continuous(breaks = year_breaks) +
  scale_color_manual(values = c("Unemployment Rate" = "#e74c3c", "Poverty Rate" = "#9b59b6")) +
  scale_y_continuous(labels = percent, expand = c(0.05, 0)) +
  labs(
    title = "Economic Stress Indicators",
    subtitle = "County-level unemployment and poverty trends",
    x = NULL,
    y = "Rate",
    color = NULL
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 15),
    plot.subtitle = element_text(color = "#666", size = 11),
    panel.grid.minor = element_blank(),
    legend.position = "bottom"
  )
```

### Housing Market Conditions

```{r county_housing_combined, fig.height=5, fig.width=10}
# Calculate scaling factor for dual y-axis (rent $ on left, % on right)
# We want percentage values (0-1 scale) to map to the rent scale
rent_min <- min(county_panel$med_rent_real, na.rm = TRUE) * 0.9
rent_max <- max(county_panel$med_rent_real, na.rm = TRUE) * 1.1
pct_min <- 0
pct_max <- max(c(county_panel$vacancy_rate, county_panel$pct_renter), na.rm = TRUE) * 1.2

# Linear transformation: pct_scaled = pct * scale_mult + scale_add
scale_mult <- (rent_max - rent_min) / (pct_max - pct_min)
scale_add <- rent_min - pct_min * scale_mult

# Prepare data with scaled percentage values
housing_data <- county_panel %>%
  mutate(
    vacancy_scaled = vacancy_rate * scale_mult + scale_add,
    renter_scaled = pct_renter * scale_mult + scale_add
  )

ggplot(housing_data, aes(x = year)) +
  # Median Rent (primary y-axis)
  geom_line(aes(y = med_rent_real, color = "Median Rent"), linewidth = 1.3) +
  geom_point(aes(y = med_rent_real, color = "Median Rent"), size = 3) +
  # Vacancy Rate (scaled to rent axis)
  geom_line(aes(y = vacancy_scaled, color = "Vacancy Rate"), linewidth = 1.3) +
  geom_point(aes(y = vacancy_scaled, color = "Vacancy Rate"), size = 3) +
  # Renter Share (scaled to rent axis)
  geom_line(aes(y = renter_scaled, color = "Renter Share"), linewidth = 1.3) +
  geom_point(aes(y = renter_scaled, color = "Renter Share"), size = 3) +
  scale_x_continuous(breaks = year_breaks) +
  scale_y_continuous(
    name = "Median Rent (2023$)",
    labels = dollar,
    limits = c(rent_min, rent_max),
    sec.axis = sec_axis(
      trans = ~ (. - scale_add) / scale_mult,
      name = "Rate (%)",
      labels = percent
    )
  ) +
  scale_color_manual(
    values = c(
      "Median Rent" = "#3498db",
      "Vacancy Rate" = "#e67e22",
      "Renter Share" = "#16a085"
    )
  ) +
  labs(
    title = "Housing Market Indicators",
    subtitle = paste0(
      "Median Rent (2023$) on left axis | Vacancy Rate (",
      sprintf("%+.1f pp", vacancy_change_county * 100),
      ") and Renter Share on right axis"
    ),
    x = NULL,
    color = NULL
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 15),
    plot.subtitle = element_text(color = "#666", size = 11),
    panel.grid.minor = element_blank(),
    legend.position = "bottom",
    axis.title.y.left = element_text(color = "#3498db", face = "bold"),
    axis.title.y.right = element_text(color = "#666", face = "bold")
  )
```

```{r affordability_analysis, fig.height=4.5}
county_panel %>%
  mutate(rent_to_income = (med_rent_real * 12) / med_income_real) %>%
  ggplot(aes(x = year, y = rent_to_income)) +
  geom_hline(yintercept = 0.30, linetype = "dashed", color = "#e74c3c", alpha = 0.6) +
  geom_line(linewidth = 1.2, color = "#34495e") +
  geom_point(size = 2.5, color = "#34495e") +
  annotate("text", x = min(county_panel$year), y = 0.305,
           label = "30% Cost Burden Threshold", hjust = 0, size = 3.5, color = "#e74c3c") +
  scale_x_continuous(breaks = function(x) seq(floor(min(x)), ceiling(max(x)), by = 1)) +
  scale_y_continuous(labels = percent, limits = c(0.15, 0.40), expand = c(0, 0)) +
  labs(
    title = "Housing Affordability: Annual Rent-to-Income Ratio",
    subtitle = "Ratio above 30% indicates cost burden per HUD guidelines",
    x = NULL,
    y = "Rent / Income"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(color = "#666", size = 12),
    panel.grid.minor = element_blank()
  )
```

<div class="insight">
**County-Level Observations:** Jefferson County shows `r if(abs(pop_change_county) < 0.02) "relatively stable population" else if(pop_change_county > 0) paste0("population growth of ", percent(pop_change_county, 0.1)) else paste0("population decline of ", percent(abs(pop_change_county), 0.1))` over the analysis period. Real median household income has `r if(income_change_county > 0) "increased" else "decreased"` by `r percent(abs(income_change_county), 0.1)`, while vacancy rates have `r if(vacancy_change_county > 0) "risen" else "fallen"` by `r sprintf("%.1f", abs(vacancy_change_county * 100))` percentage points.
</div>

---

## Portfolio Tract-Level Analysis

The portfolio's `r total_properties` properties are located across `r length(portfolio_tracts)` census tracts. This section analyzes demographic and housing trends specifically within these tracts.

### Tract Classification Distribution

```{r tract_classification_summary}
classification_summary <- tract_classifications %>%
  filter(GEOID %in% portfolio_tracts) %>%
  count(classification) %>%
  mutate(pct = n / sum(n))

classification_summary %>%
  mutate(
    classification = factor(classification, levels = c("Growth", "Stable", "Weakening")),
    n = as.integer(n),
    pct = percent(pct, 0.1)
  ) %>%
  arrange(classification) %>%
  kable(
    col.names = c("Classification", "Number of Tracts", "% of Portfolio Tracts"),
    align = c("l", "r", "r")
  )
```

### Tract Performance Metrics

```{r tract_metrics_table}
tract_classifications %>%
  filter(GEOID %in% portfolio_tracts) %>%
  left_join(tract_counts, by = c("GEOID" = "tract_geoid")) %>%
  arrange(desc(pop_cagr)) %>%
  transmute(
    `Census Tract` = GEOID,
    Classification = classification,
    `Properties` = coalesce(property_count, 0L),
    `Pop CAGR` = percent(pop_cagr, 0.1),
    `Income CAGR` = percent(income_cagr, 0.1),
    `Vacancy Δ` = sprintf("%+.1f pp", vacancy_change * 100),
    `Pop Change Sig.` = ifelse(pop_change_sig, "✓", "—"),
    `Income Change Sig.` = ifelse(income_change_sig, "✓", "—")
  ) %>%
  kable(align = c("l", "l", "r", "r", "r", "r", "c", "c"))
```

<div class="technical-note">
**Significance Testing:** Statistical significance determined using ACS margins of error. Changes marked with ✓ are distinguishable from zero at ~90% confidence level.
</div>

### Tract Trends Over Time

Each panel below represents one census tract, showing indexed trends for three key metrics. All values are normalized to the base year (= 100), so lines above 100 indicate growth and below 100 indicate decline. Panels are ordered by classification: Growth tracts first, then Stable, then Weakening.

```{r tract_trends_indexed, fig.height=12, fig.width=10}
tract_panel <- tract_history %>%
  filter(GEOID %in% portfolio_tracts) %>%
  left_join(tract_classifications %>% select(GEOID, classification), by = "GEOID")

# Index metrics to base year (first year = 100) for comparability
tract_indexed <- tract_panel %>%
  group_by(GEOID) %>%
  arrange(year) %>%
  mutate(
    Population = total_popE / first(total_popE) * 100,
    `Income (Real)` = med_income_real / first(med_income_real) * 100,
    `Vacancy Rate` = vacancy_rate / first(vacancy_rate) * 100
  ) %>%
  ungroup() %>%
  mutate(
    classification = factor(classification, levels = c("Growth", "Stable", "Weakening")),
    # Create informative facet label: Classification + last 6 digits of tract
    tract_label = paste0(
      classification, ": ",
      substr(GEOID, nchar(GEOID) - 5, nchar(GEOID))
    )
  )

# Order tracts by classification then by GEOID for consistent facet ordering
tract_order <- tract_indexed %>%
  distinct(GEOID, tract_label, classification) %>%
  arrange(classification, GEOID)

tract_indexed <- tract_indexed %>%
  mutate(tract_label = factor(tract_label, levels = tract_order$tract_label))

# Pivot to long format for plotting multiple metrics per panel
tract_long <- tract_indexed %>%
  select(GEOID, tract_label, classification, year, Population, `Income (Real)`, `Vacancy Rate`) %>%
  pivot_longer(
    cols = c(Population, `Income (Real)`, `Vacancy Rate`),
    names_to = "Metric",
    values_to = "index_value"
  ) %>%
  mutate(Metric = factor(Metric, levels = c("Population", "Income (Real)", "Vacancy Rate")))

# Calculate number of tracts to determine grid layout
n_tracts <- length(unique(tract_long$tract_label))
n_cols <- min(4, n_tracts)  # Max 4 columns

# Faceted small multiples: each tract gets its own panel with all 3 metrics
ggplot(tract_long, aes(x = year, y = index_value, color = Metric)) +
  geom_hline(yintercept = 100, linetype = "dashed", color = "#95a5a6", linewidth = 0.6) +
  geom_line(linewidth = 1) +
  geom_point(size = 1.5) +
  facet_wrap(
    ~tract_label,
    ncol = n_cols,
    scales = "free_y"
  ) +
  scale_x_continuous(breaks = year_breaks) +
  scale_color_manual(
    values = c("Population" = "#3498db", "Income (Real)" = "#27ae60", "Vacancy Rate" = "#e67e22")
  ) +
  labs(
    title = "Indexed Tract Trends (Base Year = 100)",
    subtitle = "Each panel = one census tract | Dashed line = no change from base year",
    x = NULL,
    y = "Index (Base Year = 100)",
    color = NULL
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title = element_text(face = "bold", size = 15),
    plot.subtitle = element_text(color = "#666", size = 11),
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "#f0f0f0", color = NA),
    legend.position = "bottom",
    legend.text = element_text(size = 11),
    panel.grid.minor = element_blank(),
    panel.spacing = unit(0.8, "lines")
  ) +
  guides(color = guide_legend(override.aes = list(linewidth = 2, size = 3)))
```

### Classification-Level Summary Trends

The following charts show aggregate trends by classification group. Lines represent the median value across all tracts in each group, with shaded bands showing the interquartile range (25th–75th percentile).

```{r classification_summary_population, fig.height=4, fig.width=10}
# Calculate summary statistics by classification and year
class_summary <- tract_panel %>%
  filter(!is.na(classification)) %>%
  group_by(classification, year) %>%
  summarise(
    pop_median = median(total_popE, na.rm = TRUE),
    pop_q25 = quantile(total_popE, 0.25, na.rm = TRUE),
    pop_q75 = quantile(total_popE, 0.75, na.rm = TRUE),
    income_median = median(med_income_real, na.rm = TRUE),
    income_q25 = quantile(med_income_real, 0.25, na.rm = TRUE),
    income_q75 = quantile(med_income_real, 0.75, na.rm = TRUE),
    vacancy_median = median(vacancy_rate, na.rm = TRUE),
    vacancy_q25 = quantile(vacancy_rate, 0.25, na.rm = TRUE),
    vacancy_q75 = quantile(vacancy_rate, 0.75, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(classification = factor(classification, levels = c("Growth", "Stable", "Weakening")))

# Population summary
ggplot(class_summary, aes(x = year, color = classification, fill = classification)) +
  geom_ribbon(aes(ymin = pop_q25, ymax = pop_q75), alpha = 0.15, color = NA) +
  geom_line(aes(y = pop_median), linewidth = 1.2) +
  geom_point(aes(y = pop_median), size = 2.5) +
  scale_color_manual(values = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c")) +
  scale_fill_manual(values = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c")) +
  scale_x_continuous(breaks = year_breaks) +
  scale_y_continuous(labels = comma) +
  labs(
    title = "Population by Classification",
    subtitle = "Median with IQR band (25th–75th percentile)",
    x = NULL,
    y = "Population",
    color = "Classification",
    fill = "Classification"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(color = "#666", size = 11),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )
```

```{r classification_summary_income, fig.height=4, fig.width=10}
# Income summary
ggplot(class_summary, aes(x = year, color = classification, fill = classification)) +
  geom_ribbon(aes(ymin = income_q25, ymax = income_q75), alpha = 0.15, color = NA) +
  geom_line(aes(y = income_median), linewidth = 1.2) +
  geom_point(aes(y = income_median), size = 2.5) +
  scale_color_manual(values = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c")) +
  scale_fill_manual(values = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c")) +
  scale_x_continuous(breaks = year_breaks) +
  scale_y_continuous(labels = dollar) +
  labs(
    title = "Median Household Income by Classification",
    subtitle = "Real 2023$ | Median with IQR band (25th–75th percentile)",
    x = NULL,
    y = "Income (2023$)",
    color = "Classification",
    fill = "Classification"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(color = "#666", size = 11),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )
```

```{r classification_summary_vacancy, fig.height=4, fig.width=10}
# Vacancy summary
ggplot(class_summary, aes(x = year, color = classification, fill = classification)) +
  geom_ribbon(aes(ymin = vacancy_q25, ymax = vacancy_q75), alpha = 0.15, color = NA) +
  geom_line(aes(y = vacancy_median), linewidth = 1.2) +
  geom_point(aes(y = vacancy_median), size = 2.5) +
  scale_color_manual(values = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c")) +
  scale_fill_manual(values = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c")) +
  scale_x_continuous(breaks = year_breaks) +
  scale_y_continuous(labels = percent) +
  labs(
    title = "Vacancy Rate by Classification",
    subtitle = "Median with IQR band (25th–75th percentile)",
    x = NULL,
    y = "Vacancy Rate",
    color = "Classification",
    fill = "Classification"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(color = "#666", size = 11),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )
```

### Demographic Composition (Portfolio Tracts)

```{r demographics, fig.height=5}
tract_latest_demo <- tract_history %>%
  filter(GEOID %in% portfolio_tracts, year == max(year))

# Education
p_edu <- tract_latest_demo %>%
  ggplot(aes(x = pct_bachelors)) +
  geom_histogram(bins = 15, fill = "#3498db", alpha = 0.7, color = "white") +
  scale_x_continuous(labels = percent) +
  labs(
    title = "Educational Attainment",
    subtitle = "% with Bachelor's degree or higher",
    x = "% Bachelor's+",
    y = "Number of Tracts"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 13),
    plot.subtitle = element_text(color = "#666", size = 10),
    panel.grid.minor = element_blank()
  )

# Race composition (latest year average across tracts)
race_comp <- tract_latest_demo %>%
  summarise(
    White = weighted.mean(pct_white, total_popE, na.rm = TRUE),
    Black = weighted.mean(pct_black, total_popE, na.rm = TRUE),
    Asian = weighted.mean(pct_asian, total_popE, na.rm = TRUE),
    Hispanic = weighted.mean(pct_hispanic, total_popE, na.rm = TRUE)
  ) %>%
  pivot_longer(everything(), names_to = "race", values_to = "pct") %>%
  mutate(race = factor(race, levels = c("White", "Black", "Hispanic", "Asian")))

p_race <- race_comp %>%
  ggplot(aes(x = race, y = pct, fill = race)) +
  geom_col(alpha = 0.8, width = 0.7) +
  scale_fill_manual(values = c("White" = "#95a5a6", "Black" = "#34495e",
                                "Hispanic" = "#e67e22", "Asian" = "#9b59b6")) +
  scale_y_continuous(labels = percent, expand = c(0, 0), limits = c(0, max(race_comp$pct) * 1.1)) +
  labs(
    title = "Racial/Ethnic Composition",
    subtitle = "Population-weighted average across portfolio tracts",
    x = NULL,
    y = "% of Population"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 13),
    plot.subtitle = element_text(color = "#666", size = 10),
    legend.position = "none",
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank()
  )

gridExtra::grid.arrange(p_edu, p_race, ncol = 2)
```

---

## Geographic Context: ZCTA-Level Analysis

ZIP Code Tabulation Areas (ZCTAs) provide broader geographic context beyond census tracts. The analysis includes all ZCTAs intersecting Jefferson County.

### ZCTA Classification Summary

```{r zcta_summary}
zcta_class_summary <- zcta_classifications_full %>%
  count(classification) %>%
  mutate(pct = n / sum(n))

zcta_class_summary %>%
  mutate(
    classification = factor(classification, levels = c("Growth", "Stable", "Weakening")),
    n = as.integer(n),
    pct = percent(pct, 0.1)
  ) %>%
  arrange(classification) %>%
  kable(
    col.names = c("Classification", "Number of ZCTAs", "% of ZCTAs"),
    align = c("l", "r", "r")
  )
```

### Interactive ZCTA Map with Portfolio Properties

The map below overlays portfolio properties on ZCTA classifications. Use the layer controls in the top-right to toggle between:
- **ZCTA** (ZIP Code Tabulation Areas) - broader market context
- **Census Tracts** (hidden by default) - finer geographic detail for portfolio tracts only
- **Properties** - individual property locations

Click on any property, tract, or ZCTA for detailed metrics.

```{r zcta_map, out.width='100%', fig.height=7}
if (nrow(zcta_classifications_full) > 0) {
  # Get county boundary
  county_geom <- counties(state = "AL", cb = TRUE, year = 2022, class = "sf") %>%
    filter(COUNTYFP == "073") %>%
    st_transform(4326)

  # Get ZCTA geometries
  zcta_geom <- zctas(cb = TRUE, year = 2020, class = "sf") %>%
    st_transform(4326) %>%
    st_make_valid() %>%
    st_collection_extract("POLYGON")

  # Intersect with county
  zcta_county <- zcta_geom %>%
    st_intersection(county_geom) %>%
    select(GEOID = ZCTA5CE20, geometry)

  # Join classifications
  zcta_map_data <- zcta_county %>%
    left_join(zcta_classifications_full, by = "GEOID")

  # Color palette for ZCTA
  pal_zcta <- colorFactor(
    palette = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c"),
    domain = c("Growth", "Stable", "Weakening"),
    na.color = "#bdc3c7"
  )

  # Color palette for properties
  pal_props <- colorFactor(
    palette = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c"),
    domain = c("Growth", "Stable", "Weakening"),
    na.color = "#95a5a6"
  )

  # Get census tract geometries for portfolio tracts
  portfolio_tract_ids <- prop_with_classification$tract_geoid %>% na.omit() %>% unique()

  tracts_geom <- tracts(state = "01", county = "073", cb = TRUE, year = 2022, class = "sf") %>%
    st_transform(4326) %>%
    filter(GEOID %in% portfolio_tract_ids) %>%
    select(GEOID, geometry)

  # Join tract classifications
  tracts_map_data <- tracts_geom %>%
    left_join(tract_classifications, by = "GEOID")

  # Color palette for tracts (same as ZCTA)
  pal_tract <- colorFactor(
    palette = c("Growth" = "#27ae60", "Stable" = "#f39c12", "Weakening" = "#e74c3c"),
    domain = c("Growth", "Stable", "Weakening"),
    na.color = "#bdc3c7"
  )

  # Create map - layer order: ZCTA, then tracts, then properties on top
  leaflet(width = "100%", height = 600) %>%
    addProviderTiles(providers$CartoDB.Positron) %>%
    addPolygons(
      data = zcta_map_data,
      fillColor = ~pal_zcta(classification),
      color = "#ffffff",
      weight = 1.5,
      opacity = 1,
      fillOpacity = 0.5,
      label = ~paste0("ZCTA ", GEOID, ": ", coalesce(classification, "No Data")),
      popup = ~paste0(
        "<b>ZCTA ", GEOID, "</b><br>",
        "Classification: ", coalesce(classification, "No Data"), "<br>",
        "Pop CAGR: ", percent(pop_cagr, 0.1), "<br>",
        "Income CAGR: ", percent(income_cagr, 0.1), "<br>",
        "Vacancy Change: ", sprintf("%+.1f pp", vacancy_change * 100)
      ),
      highlightOptions = highlightOptions(
        weight = 3,
        color = "#333",
        fillOpacity = 0.7,
        bringToFront = FALSE
      ),
      group = "ZCTA"
    ) %>%
    addPolygons(
      data = tracts_map_data,
      fillColor = ~pal_tract(classification),
      color = "#555555",
      weight = 2,
      opacity = 0.8,
      fillOpacity = 0.4,
      label = ~paste0("Tract ", GEOID, ": ", coalesce(classification, "No Data")),
      popup = ~paste0(
        "<b>Census Tract ", GEOID, "</b><br>",
        "Classification: ", coalesce(classification, "No Data"), "<br>",
        "Pop CAGR: ", percent(pop_cagr, 0.1),
        ifelse(pop_change_sig, " ✓", ""), "<br>",
        "Income CAGR: ", percent(income_cagr, 0.1),
        ifelse(income_change_sig, " ✓", ""), "<br>",
        "Vacancy Change: ", sprintf("%+.1f pp", vacancy_change * 100),
        ifelse(vacancy_change_sig, " ✓", "")
      ),
      highlightOptions = highlightOptions(
        weight = 3,
        color = "#000",
        fillOpacity = 0.6,
        bringToFront = FALSE
      ),
      group = "Census Tracts"
    ) %>%
    addCircleMarkers(
      data = prop_with_classification,
      ~long, ~lat,
      radius = 7,
      color = "#ffffff",
      weight = 2,
      opacity = 1,
      fillColor = ~pal_props(classification),
      fillOpacity = 0.9,
      label = ~street_address,
      labelOptions = labelOptions(
        style = list("font-weight" = "bold", "font-size" = "12px"),
        textsize = "12px",
        direction = "auto"
      ),
      popup = ~paste0(
        "<b>", full_address, "</b><br>",
        "Tract: ", tract_geoid, "<br>",
        "Classification: <b>", coalesce(classification, "Unknown"), "</b><br>",
        "Pop Change: ", percent(pop_change, 0.1),
        ifelse(pop_change_sig, " ✓", ""), "<br>",
        "Real Income Change: ", percent(income_change_real, 0.1),
        ifelse(income_change_sig, " ✓", ""), "<br>",
        "Vacancy Change: ", sprintf("%+.1f pp", vacancy_change * 100),
        ifelse(vacancy_change_sig, " ✓", "")
      ),
      group = "Properties"
    ) %>%
    addPolygons(
      data = county_geom,
      fill = FALSE,
      color = "#000000",
      weight = 3,
      opacity = 1
    ) %>%
    addLegend(
      "bottomright",
      pal = pal_zcta,
      values = zcta_map_data$classification,
      title = "Classification",
      opacity = 1,
      na.label = "No Data"
    ) %>%
    addLayersControl(
      overlayGroups = c("ZCTA", "Census Tracts", "Properties"),
      options = layersControlOptions(collapsed = FALSE)
    ) %>%
    hideGroup("Census Tracts")
}
```

---

## Portfolio Geographic Distribution

### Property Distribution by Tract

```{r property_distribution}
tract_counts %>%
  arrange(desc(property_count)) %>%
  head(10) %>%
  left_join(tract_classifications, by = c("tract_geoid" = "GEOID")) %>%
  transmute(
    `Census Tract` = tract_geoid,
    `Properties` = property_count,
    Classification = classification,
    `Pop CAGR` = percent(pop_cagr, 0.1),
    `Income CAGR` = percent(income_cagr, 0.1)
  ) %>%
  kable(
    caption = "Top 10 Tracts by Property Count",
    align = c("l", "r", "l", "r", "r")
  )
```

---

## Strategic Implications

### Key Findings

Based on the data analysis:

1. **Geographic Concentration:** The portfolio is concentrated in `r length(portfolio_tracts)` census tracts, with `r percent(growth_properties/properties_with_tract, 0.1)` of properties located in tracts classified as "Growth" based on statistically significant improvements in population and/or income.

2. **Tract-Level Fundamentals:** Portfolio tracts show `r if(length(portfolio_tracts) > 0) "varying" else "limited"` performance across demographic indicators. The tract classification methodology identifies areas with measurable positive momentum versus those showing signs of stress.

3. **County Context:** Jefferson County as a whole has experienced `r if(abs(pop_change_county) < 0.02) "stable population levels" else if(pop_change_county > 0) "modest population growth" else "population decline"`, with real income trends `r if(income_change_county > 0) "upward" else "downward"` over the analysis period.

4. **Housing Market Dynamics:** County-level vacancy rates have `r if(vacancy_change_county > 0) "increased" else "decreased"`, while rent-to-income ratios `r if(latest_county$med_rent_real * 12 / latest_county$med_income_real > 0.30) "exceed" else "remain below"` the 30% affordability threshold.

### Data Limitations

- **ACS Sampling Error:** Census tract estimates carry margins of error; only statistically significant changes are flagged in classifications
- **Time Lag:** Most recent ACS 5-year estimates lag by 1-2 years from current market conditions
- **Aggregation:** Tract-level data may mask block-level variation within neighborhoods
- **No Property Performance:** This analysis focuses solely on macro demographic trends; property-level operating metrics not included

### Recommended Next Steps

1. **Monitor Weakening Tracts:** `r weakening_properties` properties sit in tracts showing demographic stress; consider deeper investigation
2. **Validate Recent Trends:** Supplement ACS data with real-time market indicators (listing activity, permit data, etc.)
3. **Property Performance Overlay:** Link tract classifications to actual rent growth, vacancy duration, and renewal rates
4. **Expansion Analysis:** Use tract classification methodology to screen potential acquisition targets

---

<div class="methodology">

## Technical Appendix

### Data Sources

/- **Census Tract Analysis:** ACS 5-year estimates (`r analysis_period`) — used for tract classifications, property-level metrics
- **County Benchmarks:** ACS 1-year estimates (`r county_period`, excluding 2020) — provides more timely county-level context. Note: The Census Bureau did not release standard 2020 ACS 1-year estimates due to pandemic-related data collection disruptions.
- **ZCTA Analysis:** ACS 5-year estimates (`r analysis_period`) — broader geographic context
- **Geographic Boundaries:** Census TIGER/Line shapefiles (2020-2022 vintages)
- **Inflation Adjustment:** Consumer Price Index for All Urban Consumers (CPI-U), annual averages

### Variable Definitions

```{r variable_table}
variable_dictionary %>%
  kable(
    col.names = c("Metric", "Description", "Source"),
    align = c("l", "l", "l")
  )
```

### Classification Methodology

**Growth Cluster:**
- Statistically significant population increase (change > MOE at ~90% confidence)
- AND real median household income CAGR ≥ 1% annually
- AND stable or declining vacancy rate

**Weakening Cluster:**
- Statistically significant population decline
- OR statistically significant income decline
- OR vacancy rate increase ≥ 1 percentage point with statistical significance

**Stable Cluster:**
- No statistically significant changes meeting Growth or Weakening criteria

**Statistical Significance:** Determined using ACS margins of error (MOE). For derived metrics (e.g., ratios, differences), MOEs propagated using Census Bureau formulas:
- Sum MOE: `sqrt(sum(SE^2)) * 1.645`
- Ratio MOE: `sqrt((SE_num/denom)^2 + (num*SE_denom/denom^2)^2) * 1.645`
- Difference MOE: `sqrt(SE1^2 + SE2^2) * 1.645`

### Analysis Limitations

- Tract boundaries may change over time (boundary consistency not validated)
- 5-year ACS estimates represent rolling averages and overlap across years
- Small population tracts have larger margins of error
- Property geocoding accuracy depends on Census Geocoder match quality

### Software & Reproducibility

Analysis conducted in R (≥4.2) using:
- `tidycensus` for ACS data retrieval
- `tidyverse` for data manipulation
- `sf` and `tigris` for spatial operations
- `leaflet` for interactive mapping

Full code and data pipeline available in project repository.

</div>

---

<div style="text-align: center; color: #999; font-size: 0.85rem; margin-top: 60px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
Report generated `r format(Sys.time(), '%B %d, %Y at %I:%M %p')` | Analysis period: `r analysis_period`
</div>
